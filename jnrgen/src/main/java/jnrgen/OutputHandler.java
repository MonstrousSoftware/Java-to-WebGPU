package jnrgen;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Predicate;

public class OutputHandler {

    private final File outputDirectory;
    private final String packageName = "com.monstrous.wgpu";
    private final String commentHeader = "/** NOTE: THIS FILE WAS PRE-GENERATED BY JNR_GEN! */";

    private final HashMap<String, Item> types = new HashMap<>();
    private final HashMap<String, String> aliases = new HashMap<>();
    private final HashMap<String, List<ConstantItem>> constants = new HashMap<>();
    private final HashMap<String, String> opaquePointers = new HashMap<>();
    private final ArrayList<FunctionItem> functions = new ArrayList<>();        // in order of appearance
    private final HashMap<String, FunctionItem> functionMap = new HashMap<>();        // for fast lookup
    private final Map<String, Consumer<Item>> hooks = Hooks.getHooks();

    private static final List<String> excluded = Arrays.asList(
            "WgpuBindingResource_WgpuBuffer_Body",
            "WgpuBindingResource_WgpuSampler_Body",
            "WgpuBindingResource_WgpuTextureView_Body",
            "WgpuRenderPassDepthStencilAttachmentDescriptorBase_TextureViewId",
            "WgpuRenderPassDescriptor",
            "WgpuSamplerDescriptor");

    private static final Map<String, String> exportNames = Map.of(
            "SURFACE_DESCRIPTOR_FROM_WINDOWS_H_W_N_D", "SURFACE_DESCRIPTOR_FROM_WINDOWS_HWND",
            "SURFACE_DESCRIPTOR_FROM_H_T_M_L_CANVAS_ID", "SURFACE_DESCRIPTOR_FROM_HTML_CANVAS_ID",
            "SHADER_MODULE_S_P_I_R_V_DESCRIPTOR", "SHADER_MODULE_SPIRV_DESCRIPTOR",
            "SHADER_MODULE_W_G_S_L_DESCRIPTOR", "SHADER_MODULE_WGSL_DESCRIPTOR",
            "WgpuRenderPassDepthStencilAttachmentDescriptorBase_TextureViewId", "WgpuRenderPassDepthStencilDescriptor",
            "WgpuRenderPassColorAttachmentDescriptorBase_TextureViewId", "WgpuRenderPassColorDescriptor"
    );

    public OutputHandler(File outputDirectory) {
        this.outputDirectory = outputDirectory;
    }

    public void saveConstants() throws IOException{
        var writer = startFile("WebGPU_JNI.java");

        writer.write("import jnr.ffi.Pointer;\nimport jnr.ffi.types.u_int64_t;\n");
        writer.write("import jnr.ffi.types.u_int32_t;\nimport jnr.ffi.types.size_t;\n\n");

        writer.write("public interface WebGPU_JNI {\n\n");

        writer.write("// constants\n\n");
        for(var entry : constants.entrySet()){
            saveConstantGroup(writer, entry);
        }

//        writer.write("// opaque pointer types\n\n");
//        for(var entry : opaquePointers.keySet()){
//            savePointer(writer, entry);
//        }

        writer.write("\n\n// functions\n");
        for(FunctionItem entry : functions){
            entry.write(this, writer);
        }

        writer.write("}");
        writer.flush();
        writer.close();
    }

    private void saveConstantGroup(BufferedWriter writer, Map.Entry<String, List<ConstantItem>> entry) throws IOException {
        var hasClass = !entry.getKey().isBlank();

        if(hasClass){
            writer.write("    public static final class ");
            writer.write(entry.getKey().replace("Wgpu", ""));
            writer.write("{\n");
        }

        for(ConstantItem constant : entry.getValue()) {
            constant.write(writer, hasClass ? "        " : "    ");
        }

        if(hasClass){
            writer.write("    }\n");
        }

        writer.write("\n");
    }

    private void savePointer(BufferedWriter writer, String name) throws IOException {

            writer.write("    @u_int64_t long "); //Pointer ");
            writer.write(name);
            writer.write(";\n");

    }

    public BufferedWriter startFile(String name, String... imports) throws IOException {
        File file = outputDirectory.toPath().resolve(name).toFile();

        var writer = new BufferedWriter(new FileWriter(file));
        writer.write("package ");
        writer.write(packageName);
        writer.write(";\n\n");

        for(String import_: imports){
            writer.write("import ");
            writer.write(import_);
            writer.write(";\n");
        }

        writer.write("\n");
        writer.write(commentHeader);
        writer.write("\n");

        return writer;
    }

    public void runHooks(Item item) {
        var hook = hooks.get(item.getJavaTypeName());

        if(hook != null)
            hook.accept(item);
    }

    public void registerType(String type, Item item){
        types.put(type, item);
    }

    public void registerTypeAlias(String actualType, String typeAlias){
        aliases.put(typeAlias, actualType);
    }

    public void registerConstant(String associatedType, ConstantItem item){
        if(constants.containsKey(associatedType)){
            constants.get(associatedType).add(item);
        }else{
            var list = new ArrayList<ConstantItem>();
            list.add(item);

            constants.put(associatedType, list);
        }
    }
    public void registerOpaquePointer(String name){
        opaquePointers.put(name, name);
    }

    public void registerFunction(String name, FunctionItem item){

        functions.add(item);
        functionMap.put(name, item);
    }

    public static String toExportName(String key){
        return exportNames.getOrDefault(key, key);
    }

    public boolean containsType(String type) {
        return types.containsKey(type);
    }

    public boolean containsStruct(String type) {
        Item item = types.get(type);
        if(item == null)
            return false;
        return item instanceof StructItem;
    }

    public boolean containsFlags(String type) {
        Item item = types.get(type);
        if(item == null)
            return false;
        return (item instanceof EnumItem && !((EnumItem)item).contiguous);
    }



    public boolean containsAlias(String type) {
        return aliases.containsKey(type);
    }

    public boolean containsPointer(String type) {
        return opaquePointers.containsKey(type);
    }

    public boolean containsCallback(String name) {
        FunctionItem item = functionMap.get(name);
        return item != null && item.isCallback;
    }

    public Item resolveType(String type) {
        return types.get(type);
    }

    public String getAlias(String type) {
        return aliases.get(type);
    }

    public static boolean isExcluded(String name) {
        return excluded.stream().anyMatch(Predicate.isEqual(name));
    }
}
